<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Course Learning Reflections</title>
 
<body>
   /* General Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

/* Body and basic styling */
body {
    font-family: 'Poppins', sans-serif;
    line-height: 1.6;
    background-color: #f7f7f7;
    color: #333;
    text-align: center;
    padding: 20px;
}

/* Header styling */
header {
    background-color: #2c3e50;
    color: white;
    padding: 40px 0;
    margin-bottom: 40px;
}

header h1 {
    font-size: 2.5rem;
    margin-bottom: 10px;
}

header p {
    font-size: 1.2rem;
}

/* Section styling */
section {
    background-color: white;
    padding: 20px;
    margin: 20px 0;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

/* Headings inside sections */
section h2, section h3 {
    font-size: 1.8rem;
    color: #2c3e50;
    margin-bottom: 15px;
}

/* List styling */
ul {
    list-style-type: none;
    padding: 0;
}

ul li {
    background: #ecf0f1;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    font-size: 1.1rem;
}

ul li a {
    color: #3498db;
    text-decoration: none;
}

ul li a:hover {
    text-decoration: underline;
}

/* Definition list styling */
dl {
    text-align: left;
    margin-left: 30%;
    margin-right: 30%;
}

dt {
    font-weight: bold;
    color: #2c3e50;
}

dd {
    margin-bottom: 10px;
    color: #7f8c8d;
}

/* Blockquote styling */
blockquote {
    font-size: 1.2rem;
    font-style: italic;
    background-color: #f0f8ff;
    padding: 20px;
    border-left: 5px solid #3498db;
    margin: 20px 0;
}

/* Button Styling */
button {
    background-color: #27ae60;
    color: white;
    padding: 12px 30px;
    border: none;
    border-radius: 5px;
    font-size: 1rem;
    cursor: pointer;
    margin: 20px 10px;
    transition: background-color 0.3s;
}

button:hover {
    background-color: #2ecc71;
}

/* Content visibility toggle buttons */
#labReflectionContent, #theoryReflectionContent {
    display: none;
}

button:focus {
    outline: none;
}

/* Responsive Design for small screens */
@media (max-width: 768px) {
    header h1 {
        font-size: 2rem;
    }

    section {
        padding: 15px;
    }

    section h2, section h3 {
        font-size: 1.5rem;
    }

    button {
        padding: 10px 20px;
    }

    dl {
        margin-left: 10%;
        margin-right: 10%;
    }
}
    <style>
</head>
    <!-- Lab Reflection Section -->
    <section id="labReflectionContent" style="display: none;">
        <h2>ðŸ“– Reflection on Learning Data Structures and Algorithms</h2>
        <p>Throughout this course, I delved deep into fundamental data structures and algorithms, which are the backbone of efficient computing. Key topics I explored include <strong>Time Complexity Analysis</strong>, <strong>Binary Search Trees (BST)</strong>, <strong>DFS and BFS</strong>, <strong>Heap Sorting</strong>, <strong>Pattern Searching</strong>, and <strong>Graph Algorithms</strong>. Here's a reflection on what I learned, the challenges I faced, and how I approached solving complex problems.</p>

        <h3>Key Concepts Learned</h3>
        <h4>1. Time Complexity Analysis</h4>
        <p>Time complexity analysis is essential for determining the efficiency of algorithms. By mastering <strong>Big-O notation</strong>, I learned how to evaluate the performance of algorithms, especially for large input sizes. The ability to analyze an algorithm's <strong>best, worst, and average-case</strong> complexities helps select the optimal approach for solving problems.</p>

        <pre><code>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]</code></pre>

        <h4>2. Binary Search Tree (BST)</h4>
        <p>I gained a strong understanding of how <strong>BSTs</strong> allow efficient insertion, deletion, and search operations in logarithmic time. The main challenge was mastering tree traversal methods, both iterative and recursive, and understanding the importance of maintaining balance in the tree to ensure performance remains optimal.</p>

        <pre><code>class Node:
    def _init_(self, key):
        self.left = None
        self.right = None
        self.value = key

def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.value:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root</code></pre>

        <h4>3. DFS and BFS</h4>
        <p><strong>DFS</strong> is useful for exploring paths deeply, while <strong>BFS</strong> is efficient for finding the shortest path in unweighted graphs. I implemented both in various graph scenarios, such as finding connected components or shortest paths.</p>

        <pre><code>def dfs(graph, node, visited):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)</code></pre>

        <h4>4. Heap Sorting</h4>
        <p><strong>Heap Sort</strong> introduced me to the importance of the heap data structure. I learned how the binary heap allows us to efficiently retrieve the smallest or largest element and perform sorting in <strong>O(n log n)</strong> time. The challenge was understanding how the heap property is maintained during insertions and deletions.</p>

        <pre><code>def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)</code></pre>

        <h4>5. Pattern Searching</h4>
        <p>I explored various algorithms for <strong>Pattern Searching</strong>, such as <strong>Knuth-Morris-Pratt (KMP)</strong>, which is highly efficient for finding substrings in a larger string. These algorithms optimize the brute-force approach by reducing unnecessary comparisons.</p>

        <pre><code>def KMP_search(text, pattern):
    lps = [0] * len(pattern)
    j = 0
    computeLPS(pattern, lps)
    i = 0
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == len(pattern):
            print("Pattern found at index " + str(i - j))
            j = lps[j - 1]
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1</code></pre>

        <h4>6. Graph Algorithms</h4>
        <p>I learned the importance of <strong>graphs</strong> in representing real-world relationships, such as in social networks or transport systems. Implementing algorithms like <strong>Dijkstra's</strong> and <strong>Prim's</strong> for shortest paths and minimum spanning trees, respectively, was a rewarding challenge.</p>

        <pre><code>import heapq

def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances</code></pre>

        <h3>Challenges Faced</h3>
        <p>One of the biggest challenges was understanding the time and space complexities associated with each algorithm. For example, sorting algorithms like MergeSort require careful handling of memory allocation, and understanding recursive calls in depth-first search was tricky but rewarding once I understood the underlying mechanism.</p>

        <h3>Challenges in Relating to Real-World Applications</h3>
        <p>Time Complexity is theoretical, and applying it to real-world systems can sometimes be inaccurate due to factors like input size and hardware limitations. For algorithms like Graph Traversal and Heap Sorting, the scale of data in real-world applications requires additional optimizations to manage performance.</p>

        <h3>Approach and Strategy</h3>
        <p>My approach involved a balance of theory and practical implementation. After understanding the theoretical foundations, I would try to implement each algorithm from scratch, and debug my code thoroughly. Working on different problems helped me consolidate my understanding and improve my problem-solving skills.</p>
    </section>

    <!-- Theory Reflection Section -->
    <section id="theoryReflectionContent" style="display: none;">
        <h2>ðŸ“– Reflection on Learning Theory in Design Analysis and Algorithm</h2>
      <h3>1. Introduction to Theoretical Concepts</h3>
    <p>In my theoretical courses, I delved into the core principles and concepts that form the backbone of computer science. From understanding the fundamental data structures to analyzing complex algorithms, the theoretical foundations helped me develop a solid base for solving real-world problems efficiently. I learned the significance of data modeling, optimization, and computational theory, which play a critical role in designing robust systems.</p>
    
    <h3>2. Key Concepts and Topics Learned</h3>
    <ul>
        <li><strong>Data Structures:</strong> I studied various data structures like arrays, linked lists, trees, and graphs. These are essential for storing, organizing, and manipulating data in an efficient manner.</li>
        <li><strong>Algorithms:</strong> Algorithms such as quicksort, mergesort, and dynamic programming introduced me to the concept of problem-solving and the efficiency of solutions. I also learned about time complexity and how to choose the most efficient algorithm for a problem.</li>
        <li><strong>Database Design:</strong> Topics like normalization and ER modeling were integral to understanding how data is organized and stored in databases. I learned how to design a database schema that avoids redundancy and ensures data integrity.</li>
        <li><strong>Systems Design:</strong> Through concepts like microservices and architectural patterns, I learned how large-scale systems are designed to be scalable, fault-tolerant, and easy to maintain.</li>
        <li><strong>Mathematics for Computer Science:</strong> Understanding concepts like probability, combinatorics, and complexity theory was critical in analyzing algorithms and predicting their behavior in different scenarios.</li>
    </ul>

    <h3>3. Challenges Faced</h3>
    <p>Throughout my theoretical studies, I faced several challenges, particularly in understanding the complexities of algorithms. For instance, Big O notation was initially difficult to grasp as I struggled to understand how it applies to real-world scenarios. The abstraction of mathematical concepts like combinatorics and probability also posed challenges, but with continuous practice and application, I began to see their relevance in problem-solving.</p>

    <h3>4. Approach and Strategy for Mastery</h3>
    <p>My strategy for mastering theory involved a combination of consistent practice, breaking down complex topics into smaller sections, and using various learning resources. I solved problems daily, consulted textbooks and research papers, and worked on projects that applied the theoretical concepts. This hands-on approach helped me connect theory with practical implementation and solidified my understanding.</p>

    <h3>5. Theoretical Knowledge in Practice</h3>
    <p>The theoretical knowledge gained from my courses was applied in several projects, including designing optimized database schemas for real-world applications and implementing efficient sorting algorithms. I also used dynamic programming to solve complex problems like the knapsack problem and Fibonacci sequence, gaining practical insights into optimization techniques.</p>

    <h3>6. Future Learning Goals</h3>
    <p>While I have learned a lot, there is always room for improvement. I plan to deepen my understanding of advanced topics like machine learning algorithms, distributed systems, and cloud computing. Additionally, I would like to gain more practical experience in systems design, especially in large-scale applications, and understand how to implement theoretical concepts in real-world scenarios more effectively.</p>
<section>

        
    <script>
        const toggleLabReflectionBtn = document.getElementById('toggleLabReflectionBtn');
        const toggleTheoryReflectionBtn = document.getElementById('toggleTheoryReflectionBtn');
        const labReflectionContent = document.getElementById('labReflectionContent');
        const theoryReflectionContent = document.getElementById('theoryReflectionContent');

        toggleLabReflectionBtn.addEventListener('click', () => {
            theoryReflectionContent.style.display = 'none';
            labReflectionContent.style.display = labReflectionContent.style.display === 'none' ? 'block' : 'none';
        });

        toggleTheoryReflectionBtn.addEventListener('click', () => {
            labReflectionContent.style.display = 'none';
            theoryReflectionContent.style.display = theoryReflectionContent.style.display === 'none' ? 'block' : 'none';
        });
    </script>
</body>
</html>
